AWSTemplateFormatVersion: "2010-09-09"
Description: Deploys FileNet Content Manager (FNCM+BAN) into an existing Kubernetes Cluster
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Kubernetes parameters
      Parameters:
      - BastionASGName
      - CPERepoURI
      - ICNRepoURI
      - CMISRepoURI
      - CSSRepoURI
      - CRSRepoURI
      - EKSClusterName
      - QSS3BucketName
      - QSS3BucketRegion
      - QSS3KeyPrefix
      - SSLCertARN
      - NodeInstanceRoleName
      - FNCMSSMSendCommandLambdaRoleARN
      - RemoteAccessCIDR
    ParameterLabels:
      CPERepoURI:
        default: CMIS Repo URI
      ICNRepoURI:
        default: CMIS Repo URI
      CMISRepoURI:
        default: CMIS Repo URI
      CSSRepoURI:
        default: CMIS Repo URI
      CRSRepoURI:
        default: CMIS Repo URI
      EKSClusterName:
        default: EKS Cluster Name        
      QSS3BucketName:
        default: Quick Start S3 bucket name
      QSS3BucketRegion:
        default: Quick Start S3 bucket region
      QSS3KeyPrefix:
        default: Quick Start S3 key prefix
      SSLCertARN:
        default: SSL/TLS certificate ARN
      FNCMSSMSendCommandLambdaRoleARN:
        default: ARN of the role to allow SSM SendCommand action for AWS Lambda service.
      NodeInstanceRoleName:
        default: Node instance role name.
      BastionASGName:
        default: Auto Scaling Group Name of the Bastion Host
      RemoteAccessCIDR:
        default: CIDR IP range that is permitted to access the load balancers
Parameters:
  KubeClusterName:
    Type: String
  BastionASGName:
    Description: Auto Scaling Group Name of the Bastion Host
    Type: String
  CPERepoURI:
    Type: String
  ICNRepoURI:
    Type: String
  CMISRepoURI:
    Type: String
  CSSRepoURI:
    Type: String
  CRSRepoURI:
    Type: String
  EKSClusterName:
    Type: String
  QSS3BucketName:
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$
    Default: aws-quickstart
    Type: String
  QSS3BucketRegion:
    Default: 'us-east-1'
    Description: 'The AWS Region where the Quick Start S3 bucket (QSS3BucketName) is hosted. When using your own bucket, you must specify this value.'
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/.]*$
    Default: aws-quickstart-fncm/
    Type: String
  SSLCertARN:
    Type: String
  NodeInstanceRoleName:
    Type: String
  FNCMSSMSendCommandLambdaRoleARN:
    Type: String
    Description: ARN of the role to allow SSM SendCommand action for AWS Lambda service.
  RemoteAccessCIDR:
    Description: The CIDR IP range that is permitted to access the load balancers.
    Type: String
  BastionPublicIPCIDR:
    Description: The CIDR IP range of the bastion host.
    Type: String
Conditions:
  UsingDefaultBucket: !Equals [!Ref QSS3BucketName, 'aws-quickstart']
Resources:
  # Enable Cloudwatch logging
  fncmQuickStartLogs:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/Quick_Start/${AWS::StackName}-BastionPVMounts'
      RetentionInDays: 30
  # Create "fncm" namespace for the deployment
  fncmCreateNamespace:
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Namespace
        metadata:
          name: fncm
  CreateALBIngressControllerClusterRole:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: alb-ingress-controller
          labels:
            app: alb-ingress-controller
        rules:
          - apiGroups: ["", "extensions"]
            resources: ["configmaps", "endpoints", "events", "ingresses", "ingresses/status", "services"]
            verbs: ["get", "list", "watch", "create", "update", "patch"]
          - apiGroups: ["", "extensions"]
            resources: ["nodes","pods", "secrets","services", "namespaces"]
            verbs: ["get", "list", "watch"]
  CreateALBIngressControllerClusterRoleBinding:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          labels:
            app: alb-ingress-controller
          name: alb-ingress-controller
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: alb-ingress-controller
        subjects:
          - kind: ServiceAccount
            name: alb-ingress
            namespace: kube-system
  CreateServiceAccountALBIngressController:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          labels:
            app: alb-ingress-controller
          name: alb-ingress
          namespace: kube-system
  ALBIngressControllerDeploymentStack:
    DependsOn: CreateServiceAccountALBIngressController
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Cluster name
      EKSClusterName: !Ref EKSClusterName
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          labels:
            app: alb-ingress-controller
          name: alb-ingress-controller
          namespace: kube-system
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: alb-ingress-controller
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          template:
            metadata:
              labels:
                app: alb-ingress-controller
            spec:
              containers:
                - args:
                  - --ingress-class=alb
                  - --cluster-name=${EKSClusterName}
                  image: docker.io/amazon/aws-alb-ingress-controller:v1.1.4
                  imagePullPolicy: Always
                  name: alb-ingress-controller
                  resources: {}
                  terminationMessagePath: /dev/termination-log
              dnsPolicy: ClusterFirst
              restartPolicy: Always
              securityContext: {}
              terminationGracePeriodSeconds: 30
              serviceAccountName: alb-ingress
              serviceAccount: alb-ingress
#########################
# Creating PVCs for CPE #
#########################
  fncmCreateCPEBootstrapPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-bootstrapstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateCPEConfigPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-cfgstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateCPEFilestorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-filestore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 100Gi
  fncmCreateCPEFNLogPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-fnlogstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
  fncmCreateCPEICMRulePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-icmrulesstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateCPELogPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-logstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
  fncmCreateCPETextExtPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cpe-textextstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
#########################
# Creating PVCs for CSS #
#########################
  fncmCreateCSSCfgStorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'csscfgstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateCSSLogStorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'csslogstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 5Gi
  fncmCreateCSSTempStorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'csstempstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
  fncmCreateCSSIndexStorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'cssindexstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 100Gi
  fncmCreateCSSCustomStorePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'csscustomstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
#########################
# Creating PVCs for ICN #
#########################
  fncmCreateICNAsperaPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-asperastore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateICNConfigPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-cfgstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateICNLogPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-logstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
  fncmCreateICNPluginPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-pluginstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateICNVWCachePVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-vw-cachestore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
  fncmCreateICNVWLogPVC:
    DependsOn: fncmCreateNamespace
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      Manifest:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: 'icn-vw-logstore-pvc'
          namespace: !GetAtt fncmCreateNamespace.name
        spec:
          storageClassName: aws-efs
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi
  #########################################################################################################################
  ## 1. Download XML configuration files from S3
  ## 2. Download database drivers from S3
  ## 3. Download and execute shell script to (a) mount the PVs (b) copy XML and DB2 files to the appropriate directories
  #########################################################################################################################
  fncmMountPVandConfigDocument1:
    DependsOn: fncmCreateICNVWLogPVC
    Type: 'AWS::SSM::Document'
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        description: Create imagePullSecrets, mount PVs, and copy configuration XML files into various directories for the containers
        parameters:
          QSS3BucketName:
            default: !Ref QSS3BucketName
            description: The AWS S3 Bucket Name
            type: String
          QSS3KeyPrefix:
            default: !Ref QSS3KeyPrefix
            description: The AWS S3 Key Prefix
            type: String
        mainSteps:
          - action: 'aws:runShellScript'
            name: downloadDBAMCCreatePVScript
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"aws"'
                    - 's3 cp'
                    - 's3://{{QSS3BucketName}}/{{QSS3KeyPrefix}}scripts/dbamc_create_pvs.sh'
                    - '/home/ec2-user/dbamc_create_pvs.sh'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: downloadCopyFilesScript
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"aws"'
                    - 's3 cp'
                    - 's3://{{QSS3BucketName}}/{{QSS3KeyPrefix}}scripts/FNCM_copy_config_files.sh'
                    - '/home/ec2-user/FNCM_copy_config_files.sh'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: setDBAMCFilePermissions
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"chmod"'
                    - '755 /home/ec2-user/*.sh'
                    - ';'
                    - '"chown"'
                    - '-R ec2-user:ec2-user /home/ec2-user'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: runCreatePVsScript
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"/home/ec2-user/dbamc_create_pvs.sh"'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: downloadcssSelfSignedServerStore
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"aws"'
                    - 's3 cp'
                    - 's3://{{QSS3BucketName}}/{{QSS3KeyPrefix}}scripts/cssSelfsignedServerStore'
                    - '/home/ec2-user/cssSelfsignedServerStore'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: copyConfigurationFiles
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"/home/ec2-user/FNCM_copy_config_files.sh"'
              workingDirectory: '/home/ec2-user'
          - action: 'aws:runShellScript'
            name: setPVPermissionsAndOwnership
            maxAttempts: 3
            onFailure: Abort
            inputs:
              runCommand:
                - !Join
                  - ' '
                  - - '"chown"'
                    - '-R 50001:root /data'
                    - ';'
                    - '"chmod"'
                    - '-R 775 /data'
              workingDirectory: '/home/ec2-user'
  fncmExecuteMountPVandConfigDocumentLambda1:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - fncmMountPVandConfigDocument1
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.7
      Code:
        ZipFile: !Join
          - |+

          - - import boto3
            - 'import os, time,json'
            - import cfnresponse
            - import logging
            - ''
            - 'def lambda_handler(event, context):'
            - '    print(''Received event: %s'' % json.dumps(event))'
            - '    status = cfnresponse.SUCCESS'
            - '    try:'
            - '        if event[''RequestType''] == ''Delete'':'
            - '            cfnresponse.send(event, context, status, {})'
            - '        else:'
            - '            ssm = boto3.client(''ssm'')'
            - ''
            - '            asg = boto3.client(''autoscaling'')'
            - '            asg_name = event[''ResourceProperties''][''BastionASGName'']'
            - '            responseAsg = asg.describe_auto_scaling_groups(AutoScalingGroupNames=[asg_name])'
            - '            instanceId = responseAsg[''AutoScalingGroups''][0][''Instances''][0][''InstanceId'']'
            - '            ssmDocument = event[''ResourceProperties''][''SSMDocument'']'
            - '            responseData = {}'
            - ''
            - '            response=ssm.send_command('
            - '                InstanceIds = [instanceId],'
            - '                DocumentName=ssmDocument,'
            - '                TimeoutSeconds=3600,'
            - '                Comment=''Mounting PVs, copy database drivers, and copy configuration XML files'','
            - '                CloudWatchOutputConfig={''CloudWatchOutputEnabled'': True},'
            - '                MaxConcurrency=''50'','
            - '                MaxErrors=''5'','
            - '            )'
            - ''
            - '            cmdId = response[''Command''][''CommandId'']'
            - '            responseData[''CommandId''] = cmdId'
            - '            print(''Started object creation in CommandId: '' + cmdId)'
            - '            print(''Bastion Host Instance: '' + instanceId)'
            - '            cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)'
            - '    except Exception as e:'
            - '        logging.error(''Exception: %s'' % e, exc_info=True)'
            - '        status = cfnresponse.FAILED'
            - '        cfnresponse.send(event, context, status, {}, None)'
      Description: Executes PV creation and mount script on Bastion host
      MemorySize: 320
      Timeout: 180
      Role: !Ref FNCMSSMSendCommandLambdaRoleARN
  fncmExecuteConfigObjectsDocument1:
    Type: 'Custom::fncmExecuteConfigObjectsDocument1'
    Version: '1.0'
    Properties:
      ServiceToken: !GetAtt
        - fncmExecuteMountPVandConfigDocumentLambda1
        - Arn
      SSMDocument: !Ref fncmMountPVandConfigDocument1
      BastionASGName: !Ref BastionASGName
##################################################
# Deploying FNCM services (e.g., CPE, CSS, etc) #
##################################################
  fncmCPESServicetack:
    DependsOn: fncmCreateCPEFilestorePVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Service
        metadata:
          name: fncm-cpe-svc
          namespace: fncm
        spec:
          ports:
            - name: http
              protocol: TCP
              port: 9080
              targetPort: 9080
              # Statically defined nodePort so we know which port to create the ALB with
              nodePort: 31001
            - name: https
              protocol: TCP
              port: 9443
              targetPort: 9443
              # Statically defined nodePort so we know which port to create the ALB with
              nodePort: 31002
          selector:
              app: ibm-dba-contentservices
          type: NodePort
          sessionAffinity: ClientIP
  fncmCSSServicetack:
    DependsOn: fncmCreateCPEFilestorePVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Service
        metadata:
          name: fncm-css-svc
          namespace: fncm
        spec:
          ports:
            - name: cssdefault
              protocol: TCP
              port: 8191
              targetPort: 8191
            - name: cssssl
              protocol: TCP
              port: 8199
              targetPort: 8199
          selector:
              app: ibm-dba-contentsearch
          type: ClusterIP
          sessionAffinity: ClientIP
  fncmICNServicetack:
    DependsOn: fncmCreateICNVWLogPVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Service
        metadata:
          name: fncm-icn-svc
          namespace: fncm
        spec:
          ports:
            - name: http
              protocol: TCP
              port: 9080
              targetPort: 9080
              # Statically defined nodePort so we know which port to create the ALB with
              nodePort: 31003
            - name: https
              protocol: TCP
              port: 9443
              targetPort: 9443
              # Statically defined nodePort so we know which port to create the ALB with
              nodePort: 31004
          selector:
              app: ibm-dba-navigator
          type: NodePort
          sessionAffinity: ClientIP
##################################################
# Deploying FNCM pods (e.g., CPE, CSS, etc) #
##################################################
  # Deploy CPE container #
  fncmCPEDeploymentStack:
    DependsOn: fncmCreateCPEFilestorePVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: fncm-cpe
          namespace: fncm
          labels:
            app: ibm-dba-contentservices
        spec:
          replicas: 3
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          selector:
            matchLabels:
              app: ibm-dba-contentservices
          template:
            metadata:
              name: ibm-dba-contentservices
              labels:
                app: ibm-dba-contentservices
            spec:
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - ibm-dba-contentservices
                        topologyKey: "kubernetes.io/hostname"
              containers:
              - name: fncm-cpe
                image: !Ref CPERepoURI
                imagePullPolicy: IfNotPresent
                securityContext:
                # If deployment on OpenShift and image supports arbitrary uid,
                # remove runAsUser and pods will run with arbitrarily assigned user ID.
                  runAsUser: 50001
                  allowPrivilegeEscalation: true
                resources:
                  requests:
                    memory: 1024Mi
                    cpu: 500m
                  limits:
                    memory: 3072Mi
                    cpu: 1
                ports:
                  - containerPort: 9080
                    name: http
                  - containerPort: 9443
                    name: https
                env:
                  - name: "LICENSE"
                    value: 'accept'
                  - name: "PRODUCT"
                    value: 'DBAMC'
                  - name: "GCDJNDINAME"
                    value: 'FNGCDDS'
                  - name: "GCDJNDIXANAME"
                    value: 'FNGCDDSXA'
                  - name: "LICENSEMODEL"
                    value: 'FNCM.CU'
                readinessProbe:
                  httpGet:
                    path: /P8CE/Health
                    port: 9080
                    httpHeaders:
                      - name: Content-Encoding
                        value: gzip
                  initialDelaySeconds: 180
                  periodSeconds: 5
                livenessProbe:
                  httpGet:
                    path: /P8CE/Health
                    port: 9080
                    httpHeaders:
                      - name: Content-Encoding
                        value: gzip
                  initialDelaySeconds: 600
                  periodSeconds: 5
                volumeMounts:
                  - name: cpecfgstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/configDropins/overrides
                  - name: cpelogstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/logs
                  - name: cpeicmrulesstore
                    mountPath: /opt/ibm/icmrules
                  - name: cpefnlogstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/FileNet
                  - name: cpebootstrapstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/lib/bootstrap
                  - name: cpetextextstore
                    mountPath: /opt/ibm/textext
                  - name: cpefilestore
                    mountPath: /opt/ibm/asa
              volumes:
                  - name: cpecfgstore
                    persistentVolumeClaim:
                      claimName: cpe-cfgstore-pvc
                  - name: cpelogstore
                    persistentVolumeClaim:
                      claimName: cpe-logstore-pvc
                  - name: cpeicmrulesstore
                    persistentVolumeClaim:
                      claimName: cpe-icmrulesstore-pvc
                  - name: cpefnlogstore
                    persistentVolumeClaim:
                      claimName: cpe-fnlogstore-pvc
                  - name: cpebootstrapstore
                    persistentVolumeClaim:
                      claimName: cpe-bootstrapstore-pvc
                  - name: cpetextextstore
                    persistentVolumeClaim:
                      claimName: cpe-textextstore-pvc
                  - name: cpefilestore
                    persistentVolumeClaim:
                      claimName: cpe-filestore-pvc
  # Deploy CSS container #
  fncmCSSDeploymentStack:
    DependsOn: fncmCreateCPEFilestorePVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: fncm-css
          namespace: fncm
          labels:
            app: ibm-dba-contentsearch
        spec:
          replicas: 1
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          selector:
            matchLabels:
              app: ibm-dba-contentsearch
          template:
            metadata:
              name: ibm-dba-contentsearch
              labels:
                app: ibm-dba-contentsearch
            spec:
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - ibm-dba-contentsearch
                        topologyKey: "kubernetes.io/hostname"
              containers:
              - name: fncm-css
                image: !Ref CSSRepoURI
                imagePullPolicy: IfNotPresent
                securityContext:
                # If deployment on OpenShift and image supports arbitrary uid,
                # remove runAsUser and pods will run with arbitrarily assigned user ID.
                  runAsUser: 50001
                  allowPrivilegeEscalation: true
                resources:
                  requests:
                    memory: 1024Mi
                    cpu: 1
                  limits:
                    memory: 3072Mi
                    cpu: 1.5
                ports:
                  - containerPort: 8191
                    name: cssdefault
                  - containerPort: 8199
                    name: cssssl
                readinessProbe:
                  tcpSocket:
                    port: 8199
                  initialDelaySeconds: 60
                  periodSeconds: 5
                livenessProbe:
                  tcpSocket:
                    port: 8199
                  initialDelaySeconds: 120
                  periodSeconds: 5
                env:
                  - name: "LICENSE"
                    value: 'accept'
                  - name: "PRODUCT"
                    value: 'DBAMC'
                  - name: "TZ"
                    value: 'Etc/UTC'
                volumeMounts:
                  - name: csscfgstore
                    mountPath: /opt/IBM/ContentSearchServices/CSS_Server/data
                  - name: csslogstore
                    mountPath: /opt/IBM/ContentSearchServices/CSS_Server/log
                  - name: csstempstore
                    mountPath: /opt/IBM/ContentSearchServices/CSS_Server/temp
                  - name: cssindexstore
                    mountPath: /opt/ibm/indexareas
                  - name: csscustomstore
                    mountPath: /opt/IBM/ContentSearchServices/CSS_Server/config
              volumes:
                - name: csscfgstore
                  persistentVolumeClaim:
                    claimName: csscfgstore-pvc
                - name: csslogstore
                  persistentVolumeClaim:
                    claimName: csslogstore-pvc
                - name: csstempstore
                  persistentVolumeClaim:
                    claimName: csstempstore-pvc
                - name: cssindexstore
                  persistentVolumeClaim:
                    claimName: cssindexstore-pvc
                - name: csscustomstore
                  persistentVolumeClaim:
                    claimName: csscustomstore-pvc
  # Deploy ICN container
  fncmICNDeploymentStack:
    DependsOn: fncmCreateICNConfigPVC
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: fncm-icn
          namespace: fncm
          labels:
            app: ibm-dba-navigator
        spec:
          replicas: 3
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          selector:
            matchLabels:
              app: ibm-dba-navigator
          template:
            metadata:
              name: ibm-dba-navigator
              labels:
                app: ibm-dba-navigator
            spec:
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - ibm-dba-navigator
                        topologyKey: "kubernetes.io/hostname"
              containers:
              - name: fncm-icn
                image: !Ref ICNRepoURI
                imagePullPolicy: IfNotPresent
                securityContext:
                # If deployment on OpenShift and image supports arbitrary uid,
                # remove runAsUser and pods will run with arbitrarily assigned user ID.
                  runAsUser: 50001
                  allowPrivilegeEscalation: true
                resources:
                  requests:
                    memory: 1024Mi
                    cpu: 1
                  limits:
                    memory: 3072Mi
                    cpu: 1.5
                ports:
                  - containerPort: 9080
                    name: http
                  - containerPort: 9443
                    name: https
                env:
                  - name: "LICENSE"
                    value: 'accept'
                  - name: "PRODUCT"
                    value: 'DBAMC'
                  - name: "LICENSEMODEL"
                    value: 'FNCM.CU'
                  - name: "JVM_HEAP_XMS"
                    value: '1024m'
                  - name: "JVM_HEAP_XMX"
                    value: '2048m'
                  - name: "ICNJNDIDS"
                    value: 'ECMClientDS'
                  - name: "ICNDBTYPE"
                    value: 'oracle'
                  - name: "ICNSCHEMA"
                    value: 'nexususer'
                  - name: "ICNTS"
                    value: 'nexusdata_ts'
                  - name: "ICNADMIN"
                    value: "P8Admin"
                readinessProbe:
                  httpGet:
                    path: /navigator
                    port: 9080
                    httpHeaders:
                      - name: Content-Encoding
                        value: gzip
                  initialDelaySeconds: 180
                  periodSeconds: 5
                livenessProbe:
                  httpGet:
                    path: /navigator
                    port: 9080
                    httpHeaders:
                      - name: Content-Encoding
                        value: gzip
                  initialDelaySeconds: 600
                  periodSeconds: 5
                volumeMounts:
                  - name: icncfgstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/configDropins/overrides
                  - name: icnlogstore
                    mountPath: /opt/ibm/wlp/usr/servers/defaultServer/logs
                  - name: icnpluginstore
                    mountPath: /opt/ibm/plugins
                  - name: icnvwcachestore
                    mountPath: /opt/ibm/viewerconfig/cache
                  - name: icnvwlogstore
                    mountPath: /opt/ibm/viewerconfig/logs
                  - name: icnasperastore
                    mountPath: /opt/ibm/Aspera
              volumes:
                  - name: icncfgstore
                    persistentVolumeClaim:
                      claimName: icn-cfgstore-pvc
                  - name: icnlogstore
                    persistentVolumeClaim:
                      claimName: icn-logstore-pvc
                  - name: icnpluginstore
                    persistentVolumeClaim:
                      claimName: icn-pluginstore-pvc
                  - name: icnvwcachestore
                    persistentVolumeClaim:
                      claimName: icn-vw-cachestore-pvc
                  - name: icnvwlogstore
                    persistentVolumeClaim:
                      claimName: icn-vw-logstore-pvc
                  - name: icnasperastore
                    persistentVolumeClaim:
                      claimName: icn-asperastore-pvc
  # Creating Ingress Controller Policy
  CreateIngressControllerPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      Description: Policy for ALB Ingress Controller
      Path: /
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: 'acm:DescribeCertificate'
            Resource: '*'
          - Effect: Allow
            Action: 'acm:ListCertificates'
            Resource: '*'
          - Effect: Allow
            Action: 'acm:GetCertificate'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:AuthorizeSecurityGroupIngress'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:CreateSecurityGroup'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:CreateTags'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DeleteTags'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DeleteSecurityGroup'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeInstances'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeAccountAttributes'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeInstanceStatus'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeInternetGateways'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeSecurityGroups'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeSubnets'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeTags'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeVpcs'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeClassicLinkInstances'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:DescribeVpcClassicLink'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:ModifyInstanceAttribute'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:ModifyNetworkInterfaceAttribute'
            Resource: '*'
          - Effect: Allow
            Action: 'ec2:RevokeSecurityGroupIngress'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:AddTags'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ApplySecurityGroupsToLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:AttachLoadBalancerToSubnets'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:CreateListener'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:CreateLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:CreateRule'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:CreateTargetGroup'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeleteListener'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeleteLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeleteRule'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeleteTargetGroup'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DeregisterTargets'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeListeners'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeInstanceHealth'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeListenerCertificates'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeLoadBalancers'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeLoadBalancerAttributes'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeRules'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeSSLPolicies'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeTags'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeTargetGroups'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeTargetGroupAttributes'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DescribeTargetHealth'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:DisableAvailabilityZonesForLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:EnableAvailabilityZonesForLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ModifyListener'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ModifyLoadBalancerAttributes'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ModifyRule'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ModifyTargetGroup'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:ModifyTargetGroupAttributes'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:RegisterTargets'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:RemoveTags'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:SetIpAddressType'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:SetSecurityGroups'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:SetSubnets'
            Resource: '*'
          - Effect: Allow
            Action: 'elasticloadbalancing:SetWebACL'
            Resource: '*'
          - Effect: Allow
            Action: 'iam:CreateServiceLinkedRole'
            Resource: '*'
          - Effect: Allow
            Action: 'iam:GetServerCertificate'
            Resource: '*'
          - Effect: Allow
            Action: 'iam:ListServerCertificates'
            Resource: '*'
          - Effect: Allow
            Action: 'waf-regional:GetWebACLForResource'
            Resource: '*'
          - Effect: Allow
            Action: 'waf-regional:GetWebACL'
            Resource: '*'
          - Effect: Allow
            Action: 'waf-regional:AssociateWebACL'
            Resource: '*'
          - Effect: Allow
            Action: 'waf-regional:DisassociateWebACL'
            Resource: '*'
          - Effect: Allow
            Action: 'tag:GetResources'
            Resource: '*'
          - Effect: Allow
            Action: 'tag:TagResources'
            Resource: '*'
          - Effect: Allow
            Action: 'waf:GetWebACL'
            Resource: '*'
      Roles: [!Ref NodeInstanceRoleName]
  # Create CPE Load Balancer
  CreateCPELoadBalancer:
    Type: "Custom::KubeManifest"
    DependsOn: fncmCPEDeploymentStack
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: extensions/v1beta1
        kind: Ingress
        metadata:
          name: cpe-ingress
          namespace: fncm
          annotations:
            kubernetes.io/ingress.class: alb
            alb.ingress.kubernetes.io/scheme: internet-facing
            alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80}, {"HTTPS":443}]'
            alb.ingress.kubernetes.io/certificate-arn: ${SSLCertARN}
            alb.ingress.kubernetes.io/inbound-cidrs: ${RemoteAccessCIDR},${BastionPublicIPCIDR}
            alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=3600
          labels:
            app: cpe-ingress
        spec:
          rules:
            - http:
                paths:
                  - path: /*
                    backend:
                      serviceName: fncm-cpe-svc
                      servicePort: 9080
  CreateICNLoadBalancer:
    Type: "Custom::KubeManifest"
    DependsOn: fncmICNDeploymentStack
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:EKS-QuickStart-KubeManifest-${KubeClusterName}"
      ClusterName: !Ref KubeClusterName
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: extensions/v1beta1
        kind: Ingress
        metadata:
          name: icn-ingress
          namespace: fncm
          annotations:
            kubernetes.io/ingress.class: alb
            alb.ingress.kubernetes.io/scheme: internet-facing
            alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80}, {"HTTPS":443}]'
            alb.ingress.kubernetes.io/certificate-arn: ${SSLCertARN}
            alb.ingress.kubernetes.io/inbound-cidrs: ${RemoteAccessCIDR},${BastionPublicIPCIDR}
            alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=3600
          labels:
            app: icn-ingress
        spec:
          rules:
            - http:
                paths:
                  - path: /*
                    backend:
                      serviceName: fncm-icn-svc
                      servicePort: 9080
